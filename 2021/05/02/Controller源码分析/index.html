<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Controller 源码分析 - Fusidic&#039;s blog</title><meta description="源码角度学习 Controller。(Kubernetes 1.19)"><meta property="og:type" content="blog"><meta property="og:title" content="Controller 源码分析"><meta property="og:url" content="https://fusidic.github.io/"><meta property="og:site_name" content="Fusidic&#039;s blog"><meta property="og:description" content="源码角度学习 Controller。(Kubernetes 1.19)"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://i.loli.net/2021/05/14/aXRAn3yQZUrlCvw.png"><meta property="og:image" content="https://i.loli.net/2021/05/14/aXRAn3yQZUrlCvw.png"><meta property="og:image" content="https://i.loli.net/2021/05/14/bcm9oyufI14dqpP.jpg"><meta property="og:image" content="https://i.loli.net/2021/05/14/cX6fvxIWiKNqEe8.png"><meta property="article:published_time" content="2021-05-02T14:53:42.000Z"><meta property="article:modified_time" content="2021-05-14T11:17:39.295Z"><meta property="article:author" content="arithbar"><meta property="article:tag" content="Kubernetes"><meta property="article:tag" content="Operators"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://i.loli.net/2021/05/14/aXRAn3yQZUrlCvw.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://fusidic.github.io/2021/05/02/Controller%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},"headline":"Fusidic's blog","image":["https://i.loli.net/2021/05/14/aXRAn3yQZUrlCvw.png","https://i.loli.net/2021/05/14/aXRAn3yQZUrlCvw.png","https://i.loli.net/2021/05/14/bcm9oyufI14dqpP.jpg","https://i.loli.net/2021/05/14/cX6fvxIWiKNqEe8.png"],"datePublished":"2021-05-02T14:53:42.000Z","dateModified":"2021-05-14T11:17:39.295Z","author":{"@type":"Person","name":"arithbar"},"description":"源码角度学习 Controller。(Kubernetes 1.19)"}</script><link rel="canonical" href="https://fusidic.github.io/2021/05/02/Controller%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><link rel="icon" href="/img/favicon.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Fusidic&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/fusidic"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2021-05-02T14:53:42.000Z" title="2021-05-02T14:53:42.000Z">2021-05-02</time><span class="level-item"><a class="link-muted" href="/categories/Deployments/">Deployments</a><span> / </span><a class="link-muted" href="/categories/Deployments/Kubernetes/">Kubernetes</a></span><span class="level-item">29 分钟 读完 (大约 4414 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Controller 源码分析</h1><div class="content"><p>源码角度学习 Controller。(Kubernetes 1.19)</p>
<a id="more"></a>

<p>下面是一张关于 Controller 运行流程的图，非常清晰易懂，在网上广为流传。</p>
<p><img src="https://i.loli.net/2021/05/14/aXRAn3yQZUrlCvw.png" alt="Controller%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2076b5a3082b8842e1b8549a128955b05b/Untitled.png"></p>
<p>整个控制器的处理流程以间隔线为界分成了上下两个部分：</p>
<p>上半部分与 api server 交互，监听资源状态并将资源变更事件发送到 Resource Event Handler 中，这部分的代码逻辑在 Kubernetes 各个组件中都有使用，因此将其封装为一个 client-go 包；</p>
<p>下半部分为 controller 对事件的处理，这部分控制器完成了资源实际状态与期望状态的“拟合”，主要的控制逻辑在这个地方实现，后文中以 Deployment 为例进行分析。</p>
<p>本文希望更加深入，从源码层级上观察与理解 Controller 的具体逻辑和实现。</p>
<br/>

<h1 id="启动控制器"><a href="#启动控制器" class="headerlink" title="启动控制器"></a>启动控制器</h1><p>首先不去管控制器实现的细节，我们从入口开始，了解如何启动一个控制器。</p>
<p>内置控制器通常在 <code>cmd/kube-controller-manager/app/controllermanager.go</code> 中进行初始化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewControllerInitializers is a public map of named controller groups (you can start more than one in an init func)</span></span><br><span class="line"><span class="comment">// paired to their InitFunc.  This allows for structured downstream composition and subdivision.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewControllerInitializers</span><span class="params">(loopMode ControllerLoopMode)</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">InitFunc</span></span> &#123;</span><br><span class="line">	controllers := <span class="keyword">map</span>[<span class="keyword">string</span>]InitFunc&#123;&#125;</span><br><span class="line">	controllers[<span class="string">"endpoint"</span>] = startEndpointController</span><br><span class="line">	controllers[<span class="string">"endpointslice"</span>] = startEndpointSliceController</span><br><span class="line">	controllers[<span class="string">"endpointslicemirroring"</span>] = startEndpointSliceMirroringController</span><br><span class="line">	controllers[<span class="string">"replicationcontroller"</span>] = startReplicationController</span><br><span class="line">	controllers[<span class="string">"podgc"</span>] = startPodGCController</span><br><span class="line">	controllers[<span class="string">"resourcequota"</span>] = startResourceQuotaController</span><br><span class="line">	controllers[<span class="string">"namespace"</span>] = startNamespaceController</span><br><span class="line">	controllers[<span class="string">"serviceaccount"</span>] = startServiceAccountController</span><br><span class="line">	controllers[<span class="string">"garbagecollector"</span>] = startGarbageCollectorController</span><br><span class="line">	controllers[<span class="string">"daemonset"</span>] = startDaemonSetController</span><br><span class="line">	controllers[<span class="string">"job"</span>] = startJobController</span><br><span class="line">	controllers[<span class="string">"deployment"</span>] = startDeploymentController</span><br><span class="line">	controllers[<span class="string">"replicaset"</span>] = startReplicaSetController</span><br><span class="line">	controllers[<span class="string">"horizontalpodautoscaling"</span>] = startHPAController</span><br><span class="line">	controllers[<span class="string">"disruption"</span>] = startDisruptionController</span><br><span class="line">	controllers[<span class="string">"statefulset"</span>] = startStatefulSetController</span><br><span class="line">	controllers[<span class="string">"cronjob"</span>] = startCronJobController</span><br><span class="line">	controllers[<span class="string">"csrsigning"</span>] = startCSRSigningController</span><br><span class="line">	controllers[<span class="string">"csrapproving"</span>] = startCSRApprovingController</span><br><span class="line">	controllers[<span class="string">"csrcleaner"</span>] = startCSRCleanerController</span><br><span class="line">	controllers[<span class="string">"ttl"</span>] = startTTLController</span><br><span class="line">	controllers[<span class="string">"bootstrapsigner"</span>] = startBootstrapSignerController</span><br><span class="line">	controllers[<span class="string">"tokencleaner"</span>] = startTokenCleanerController</span><br><span class="line">	controllers[<span class="string">"nodeipam"</span>] = startNodeIpamController</span><br><span class="line">	controllers[<span class="string">"nodelifecycle"</span>] = startNodeLifecycleController</span><br><span class="line">	<span class="keyword">if</span> loopMode == IncludeCloudLoops &#123;</span><br><span class="line">		controllers[<span class="string">"service"</span>] = startServiceController</span><br><span class="line">		controllers[<span class="string">"route"</span>] = startRouteController</span><br><span class="line">		controllers[<span class="string">"cloud-node-lifecycle"</span>] = startCloudNodeLifecycleController</span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> volume controller into the IncludeCloudLoops only set.</span></span><br><span class="line">	&#125;</span><br><span class="line">	controllers[<span class="string">"persistentvolume-binder"</span>] = startPersistentVolumeBinderController</span><br><span class="line">	controllers[<span class="string">"attachdetach"</span>] = startAttachDetachController</span><br><span class="line">	controllers[<span class="string">"persistentvolume-expander"</span>] = startVolumeExpandController</span><br><span class="line">	controllers[<span class="string">"clusterrole-aggregation"</span>] = startClusterRoleAggregrationController</span><br><span class="line">	controllers[<span class="string">"pvc-protection"</span>] = startPVCProtectionController</span><br><span class="line">	controllers[<span class="string">"pv-protection"</span>] = startPVProtectionController</span><br><span class="line">	controllers[<span class="string">"ttl-after-finished"</span>] = startTTLAfterFinishedController</span><br><span class="line">	controllers[<span class="string">"root-ca-cert-publisher"</span>] = startRootCACertPublisher</span><br><span class="line">	controllers[<span class="string">"ephemeral-volume"</span>] = startEphemeralVolumeController</span><br><span class="line">	<span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(genericfeatures.APIServerIdentity) &amp;&amp;</span><br><span class="line">		utilfeature.DefaultFeatureGate.Enabled(genericfeatures.StorageVersionAPI) &#123;</span><br><span class="line">		controllers[<span class="string">"storage-version-gc"</span>] = startStorageVersionGCController</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> controllers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化函数 initFunc 在 <code>cmd/kube-controller-manager/app/</code> 目录下个各文件中，以 Deployment 为例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startDeploymentController</span><span class="params">(ctx ControllerContext)</span> <span class="params">(http.Handler, <span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !ctx.AvailableResources[schema.GroupVersionResource&#123;Group: <span class="string">"apps"</span>, Version: <span class="string">"v1"</span>, Resource: <span class="string">"deployments"</span>&#125;] &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	dc, err := deployment.NewDeploymentController(</span><br><span class="line">		ctx.InformerFactory.Apps().V1().Deployments(),</span><br><span class="line">		ctx.InformerFactory.Apps().V1().ReplicaSets(),</span><br><span class="line">		ctx.InformerFactory.Core().V1().Pods(),</span><br><span class="line">		ctx.ClientBuilder.ClientOrDie(<span class="string">"deployment-controller"</span>),</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">true</span>, fmt.Errorf(<span class="string">"error creating Deployment controller: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> dc.Run(<span class="keyword">int</span>(ctx.ComponentConfig.DeploymentController.ConcurrentDeploymentSyncs), ctx.Stop)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里的 <code>dc.Run()</code> 方法，第一个参数为 worker 的数量，第二个参数为空结构体，用来接收异常停止的信号。</p>
<p>与之类似的，CRD 控制器的启动逻辑也是相同的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    mydemoInformerFactory := informers.NewSharedInformerFactory(mydemoClient, time.Second*<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成一个crddemo组的Mydemo对象传递给自定义控制器</span></span><br><span class="line">    controller := NewController(kubeClient, mydemoClient,</span><br><span class="line">        mydemoInformerFactory().V1().Mydemos())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> mydemoInformerFactory.Start(stopCh)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err = controller.Run(<span class="number">2</span>, stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Fatalf(<span class="string">"Error running controller: %s"</span>, err.Error())</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>内置控制器中的 <code>ctx.InformerFactory</code> 下面 <code>mydemoInformerFactory</code> 等价，本身也是对 <code>informers.SharedInformerFactory</code> 的封装。</p>
<br/>

<h1 id="构建控制器"><a href="#构建控制器" class="headerlink" title="构建控制器"></a>构建控制器</h1><p>那么构建一个控制器需要做些什么？首先看控制器需要完成什么工作：</p>
<ul>
<li>从 api server 中监听对象的变化情况 (Client → Reflector List&amp;Watch) ；</li>
<li>将对象变化的事件同步到缓存中 (Indexer) ；</li>
<li>根据事件类型，触发注册的 ResourceEventHandler，完成业务逻辑 (Informer)。</li>
</ul>
<p>那么为了方便阅读，这里把这张图又放了一遍，我们将以图中的编号为序，逐步分析控制器的代码细节。</p>
<p><img src="https://i.loli.net/2021/05/14/aXRAn3yQZUrlCvw.png" alt="Controller%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2076b5a3082b8842e1b8549a128955b05b/Untitled.png"></p>
<br/>

<h1 id="Client-go"><a href="#Client-go" class="headerlink" title="Client-go"></a>Client-go</h1><p>Kubernetes 项目中，将与 api server 交互的操作进行了封装，这也就是 client-go，下面以 CRD 中的 controller 为例分析具体的流程：</p>
<h2 id="1-List-amp-Watch"><a href="#1-List-amp-Watch" class="headerlink" title="1) List &amp; Watch"></a>1) List &amp; Watch</h2><p>client 对制定 Kubernetes 资源进行监控 (Watch)，主要依赖于 Reflector 。初始化 Reflector 需要传入 ListerWatcher 数据接口对象，实现 List 和 Watch 方法。</p>
<p>调用的起点是 <code>main.go</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> mydemoInformerFactory.Start(stopCh)</span><br></pre></td></tr></table></figure>

<p>这里调用的是 <code>pkg/client/informers/externalversions/factory.go</code> 中的 <code>Start</code> 方法，该方法会把工厂 factory 中保存的所有 informer 全部启动：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *sharedInformerFactory)</span> <span class="title">Start</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	f.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> informerType, informer := <span class="keyword">range</span> f.informers &#123;</span><br><span class="line">		<span class="keyword">if</span> !f.startedInformers[informerType] &#123;</span><br><span class="line">			<span class="keyword">go</span> informer.Run(stopCh)</span><br><span class="line">			f.startedInformers[informerType] = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>informer 的实际类型是 <code>sharedIndexInformer</code> ，因此此处调用的就是 client-go 库 <code>tools/cache/shared_informer.go</code>  中的 <code>Run</code> 方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sharedIndexInformer)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line"></span><br><span class="line">	fifo := NewDeltaFIFOWithOptions(DeltaFIFOOptions&#123;</span><br><span class="line">		KnownObjects:          s.indexer,</span><br><span class="line">		EmitDeltaTypeReplaced: <span class="literal">true</span>,</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	cfg := &amp;Config&#123;</span><br><span class="line">		Queue:            fifo,</span><br><span class="line">		ListerWatcher:    s.listerWatcher,</span><br><span class="line">		ObjectType:       s.objectType,</span><br><span class="line">		FullResyncPeriod: s.resyncCheckPeriod,</span><br><span class="line">		RetryOnError:     <span class="literal">false</span>,</span><br><span class="line">		ShouldResync:     s.processor.shouldResync,</span><br><span class="line"></span><br><span class="line">		Process: s.HandleDeltas,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		s.startedLock.Lock()</span><br><span class="line">		<span class="keyword">defer</span> s.startedLock.Unlock()</span><br><span class="line"></span><br><span class="line">		s.controller = New(cfg)</span><br><span class="line">		s.controller.(*controller).clock = s.clock</span><br><span class="line">		s.started = <span class="literal">true</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Separate stop channel because Processor should be stopped strictly after controller</span></span><br><span class="line">	processorStopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">var</span> wg wait.Group</span><br><span class="line">	<span class="keyword">defer</span> wg.Wait()              <span class="comment">// Wait for Processor to stop</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(processorStopCh) <span class="comment">// Tell Processor to stop</span></span><br><span class="line">	wg.StartWithChannel(processorStopCh, s.cacheMutationDetector.Run)</span><br><span class="line">	wg.StartWithChannel(processorStopCh, s.processor.run)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		s.startedLock.Lock()</span><br><span class="line">		<span class="keyword">defer</span> s.startedLock.Unlock()</span><br><span class="line">		s.stopped = <span class="literal">true</span> <span class="comment">// Don't want any new listeners</span></span><br><span class="line">	&#125;()</span><br><span class="line">	s.controller.Run(stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，这里的 controller 并不是图中的控制器，这个 controller 更多的是 sharedIndexInformer 中一个底层控制逻辑的实现，可以看到在 controller 的初始化中，就直接新建了一个 Reflector：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controller)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		&lt;-stopCh</span><br><span class="line">		c.config.Queue.Close()</span><br><span class="line">	&#125;()</span><br><span class="line">	r := NewReflector(</span><br><span class="line">		c.config.ListerWatcher,</span><br><span class="line">		c.config.ObjectType,</span><br><span class="line">		c.config.Queue,</span><br><span class="line">		c.config.FullResyncPeriod,</span><br><span class="line">	)</span><br><span class="line">	r.ShouldResync = c.config.ShouldResync</span><br><span class="line">	r.clock = c.clock</span><br><span class="line"></span><br><span class="line">	c.reflectorMutex.Lock()</span><br><span class="line">	c.reflector = r</span><br><span class="line">	c.reflectorMutex.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> wg wait.Group</span><br><span class="line">	<span class="keyword">defer</span> wg.Wait()</span><br><span class="line"></span><br><span class="line">	wg.StartWithChannel(stopCh, r.Run)</span><br><span class="line"></span><br><span class="line">	wait.Until(c.processLoop, time.Second, stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面提到，创建 Reflector 需要实现 List 与 Watch 方法，这一步在创建 SharedIndexInformer 时传入：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFilteredMydemoInformer</span><span class="params">(client versioned.Interface, namespace <span class="keyword">string</span>, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc)</span> <span class="title">cache</span>.<span class="title">SharedIndexInformer</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> cache.NewSharedIndexInformer(</span><br><span class="line">		&amp;cache.ListWatch&#123;</span><br><span class="line">			ListFunc: <span class="function"><span class="keyword">func</span><span class="params">(options metav1.ListOptions)</span> <span class="params">(runtime.Object, error)</span></span> &#123;</span><br><span class="line">				<span class="keyword">if</span> tweakListOptions != <span class="literal">nil</span> &#123;</span><br><span class="line">					tweakListOptions(&amp;options)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> client.CrddemoV1().Mydemos(namespace).List(context.TODO(), options)</span><br><span class="line">			&#125;,</span><br><span class="line">			WatchFunc: <span class="function"><span class="keyword">func</span><span class="params">(options metav1.ListOptions)</span> <span class="params">(watch.Interface, error)</span></span> &#123;</span><br><span class="line">				<span class="keyword">if</span> tweakListOptions != <span class="literal">nil</span> &#123;</span><br><span class="line">					tweakListOptions(&amp;options)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> client.CrddemoV1().Mydemos(namespace).Watch(context.TODO(), options)</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		&amp;crddemov1.Mydemo&#123;&#125;,</span><br><span class="line">		resyncPeriod,</span><br><span class="line">		indexers,</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传入的 ListFunc 和 WatchFunc 完成了对 client 中 List/Watch 方法的封装，这两个方法都是由代码生成器生成。</p>
<p>同时也注意到，在创建 Reflector 时，也同时创建了一个 DeltaFIFO 作为 Store 接口的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client-go/tools/cache/shared_informer.go</span></span><br><span class="line"><span class="comment">// sharedIndexInformer.Run 中创建 DeltaFIFO</span></span><br><span class="line">fifo := NewDeltaFIFOWithOptions(DeltaFIFOOptions&#123;</span><br><span class="line">	KnownObjects:          s.indexer,</span><br><span class="line">	EmitDeltaTypeReplaced: <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">cfg := &amp;Config&#123;</span><br><span class="line">	Queue:            fifo,</span><br><span class="line">	ListerWatcher:    s.listerWatcher,</span><br><span class="line">	ObjectType:       s.objectType,</span><br><span class="line">	FullResyncPeriod: s.resyncCheckPeriod,</span><br><span class="line">	RetryOnError:     <span class="literal">false</span>,</span><br><span class="line">	ShouldResync:     s.processor.shouldResync,</span><br><span class="line"></span><br><span class="line">	Process: s.HandleDeltas,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client-go/tools/cache/controller.go</span></span><br><span class="line"><span class="comment">// controller.Run 中创建 Reflector</span></span><br><span class="line">r := NewReflector(</span><br><span class="line">	c.config.ListerWatcher,</span><br><span class="line">	c.config.ObjectType,</span><br><span class="line">	c.config.Queue,</span><br><span class="line">	c.config.FullResyncPeriod,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<br/>

<h2 id="2-Add-Object"><a href="#2-Add-Object" class="headerlink" title="2) Add Object"></a>2) Add Object</h2><ol>
<li><p>在程序第一次运行时会首先进行一次 List，用来获取该资源下所有对象数据，并导入到 DeltaFIFO 中，这部分逻辑在 <code>cilent-go/tools/cache/reflector.go</code> 的 <code>Reflector.ListAndWatch</code> 方法中，具体代码比较长，这里把几个关键步骤以流程图的形式画出来：</p>
 <img src="https://i.loli.net/2021/05/14/bcm9oyufI14dqpP.jpg" alt="流程图" style="zoom:50%;" />

<p> List 调用的是初始化 Informer 时传入的 ListFunc 方法， <code>r.syncWith</code> 将资源对象传入 DeltaFIFO 时调用的是 DeltaFIFO 中的 Replace 方法 。</p>
</li>
<li><p>另外还需要监控资源对象的变更情况，监控 (Watch) 操作是通过 HTTP 协议与 api server 建立长连接，使用 HTTP 协议的分块传输编码来实现，Reflector 中关于 Watch 部分的代码：</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">	<span class="comment">// give the stopCh a chance to stop the loop, even in case of continue statements further down on errors</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	timeoutSeconds := <span class="keyword">int64</span>(minWatchTimeout.Seconds() * (rand.Float64() + <span class="number">1.0</span>))</span><br><span class="line">	options = metav1.ListOptions&#123;</span><br><span class="line">		ResourceVersion: resourceVersion,</span><br><span class="line">		TimeoutSeconds: &amp;timeoutSeconds,</span><br><span class="line">		AllowWatchBookmarks: <span class="literal">true</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	w, err := r.listerWatcher.Watch(options)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := r.watchHandler(w, &amp;resourceVersion, resyncerrc, stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err != errorStopRequested &#123;</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>[r.listerWatcher.Watch](&lt;http://r.listerWatcher.Watch&gt;)</code> 函数同样也是调用 Informer 中的 WatchFunc， <code>r.watchHandler</code> 用于处理资源对象的变更事件，当触发 Added、Updated、Deleted 事件时，会将事件更新到 DeltaFIFO 中。</p>
<p> 所有向 DeltaFIFO 中传递资源对象都是调用 <a href="http://r.store">r.store</a> 中的方法（其实就是 Store 抽象接口由 DeltaFIFO 实现，如果这里需要实现一个不一样的队列，可以直接自己写个队列，初始化 SharedInformer 时代入进去就行）</p>
</li>
</ol>
<br/>

<h2 id="3-Pop-Object"><a href="#3-Pop-Object" class="headerlink" title="3) Pop Object"></a>3) Pop Object</h2><p>上面提到了 Reflector 通过调用 <code>[r.store](http://r.store)</code> 中的方法，完成向 DeltaFIFO 中添加对象的操作，那么这里就从 DeltaFIFO 本身的角度上来讲讲它的数据结构，以及入队出队的具体实现。</p>
<p>DeltaFIFO 的 Add、Update、Delete 方法中，都用到了 <code>queueActionLocked()</code>，它是 DeltaFIFO 实现的关键：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *DeltaFIFO)</span> <span class="title">queueActionLocked</span><span class="params">(actionType DeltaType, obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	id, err := f.KeyOf(obj)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> KeyError&#123;obj, err&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	newDeltas := <span class="built_in">append</span>(f.items[id], Delta&#123;actionType, obj&#125;)</span><br><span class="line">	newDeltas = dedupDeltas(newDeltas)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(newDeltas) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> _, exists := f.items[id]; !exists &#123;</span><br><span class="line">			f.queue = <span class="built_in">append</span>(f.queue, id)</span><br><span class="line">		&#125;</span><br><span class="line">		f.items[id] = newDeltas</span><br><span class="line">		f.cond.Broadcast()</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">delete</span>(f.items, id)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DeltaFIFO 的结构如下图所示，对于每个传入的 obj，都会根据 KeyOf 计算其 Key 值，再根据 Key 存入到 items 中，items 是一个 map 类型，键为这里得到的 Key，值为obj的切片类型。</p>
<p>在 obj 导入到 items 后，需要使用 <code>dedupDeltas</code> 进行一次去重操作。将 newDeltas 正确地放入 DeltaFIFO 中，会通知所有下游 goroutine 解除阻塞。</p>
<p><img src="https://i.loli.net/2021/05/14/cX6fvxIWiKNqEe8.png" alt="Controller%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2076b5a3082b8842e1b8549a128955b05b/-2.png"></p>
<p>以上可以被称为 DeltaFIFO 的“生产者”过程，下面来看下游 goroutine 如何“消费” DeltaObj。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *DeltaFIFO)</span> <span class="title">Pop</span><span class="params">(process PopProcessFunc)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">	f.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> <span class="built_in">len</span>(f.queue) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> f.IsClosed() &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, ErrFIFOClosed</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			f.cond.Wait()</span><br><span class="line">		&#125;</span><br><span class="line">		id := f.queue[<span class="number">0</span>]</span><br><span class="line">		f.queue = f.queue[<span class="number">1</span>:]</span><br><span class="line">		<span class="keyword">if</span> f.initialPopulationCount &gt; <span class="number">0</span> &#123;</span><br><span class="line">			f.initialPopulationCount--</span><br><span class="line">		&#125;</span><br><span class="line">		item, ok := f.items[id]</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="comment">// Item may have been deleted subsequently.</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">delete</span>(f.items, id)</span><br><span class="line">		err := process(item)</span><br><span class="line">		<span class="keyword">if</span> e, ok := err.(ErrRequeue); ok &#123;</span><br><span class="line">			f.addIfNotPresent(id, item)</span><br><span class="line">			err = e.Err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Don't need to copyDeltas here, because we're transferring</span></span><br><span class="line">		<span class="comment">// ownership to the caller.</span></span><br><span class="line">		<span class="keyword">return</span> item, err</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Pop 方法作为消费者方法使用，从 DeltaFIFO 的头部取出最早进入队列的资源对象，Pop 方法须传入 process 方法，这是用来接收并处理资源对象的回调方法。</p>
<p>当队列中没有数据时，通过 <code>f.cond.wait</code> 阻塞等待数据，只有收到 <code>cond.Broadcast</code> 时才会解除当前的阻塞状态，如果队列中部为空，取出 <code>f.queue</code> 头部的资源对象， 并将该对象传入 process 回调函数中，由上层消费者进行处理。</p>
<p>那么上层消费者是在什么时候将处理函数传入的呢？回到上面创建 <code>sharedIndexInformer.Run</code> 的代码中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client-go/tools/cache/shared_informer.go</span></span><br><span class="line"><span class="comment">// sharedIndexInformer.Run 中创建 DeltaFIFO</span></span><br><span class="line">fifo := NewDeltaFIFOWithOptions(DeltaFIFOOptions&#123;</span><br><span class="line">	KnownObjects:          s.indexer,</span><br><span class="line">	EmitDeltaTypeReplaced: <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">cfg := &amp;Config&#123;</span><br><span class="line">	Queue:            fifo,</span><br><span class="line">	ListerWatcher:    s.listerWatcher,</span><br><span class="line">	ObjectType:       s.objectType,</span><br><span class="line">	FullResyncPeriod: s.resyncCheckPeriod,</span><br><span class="line">	RetryOnError:     <span class="literal">false</span>,</span><br><span class="line">	ShouldResync:     s.processor.shouldResync,</span><br><span class="line"></span><br><span class="line">	Process: s.HandleDeltas,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个地方首次制定了 Process 方法为 <code>s.HandleDeltas</code> ，同时在 <code>client-go/tools/cache/controller.go</code> 中的控制循环中，循环调用了 Pop 方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controller)</span> <span class="title">processLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		obj, err := c.config.Queue.Pop(PopProcessFunc(c.config.Process))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err == ErrFIFOClosed &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.config.RetryOnError &#123;</span><br><span class="line">				<span class="comment">// This is the safe way to re-enqueue.</span></span><br><span class="line">				c.config.Queue.AddIfNotPresent(obj)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>HandlDeltas</code> 作为 process 的回调函数，当资源对象的操作类型为 Added、Updated、Deleted 时，将该资源对象存储到 Indexer 中，并通过 distribute 函数将资源对象分发到 SharedInformer：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sharedIndexInformer)</span> <span class="title">HandleDeltas</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	s.blockDeltas.Lock()</span><br><span class="line">	<span class="keyword">defer</span> s.blockDeltas.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// from oldest to newest</span></span><br><span class="line">	<span class="keyword">for</span> _, d := <span class="keyword">range</span> obj.(Deltas) &#123;</span><br><span class="line">		<span class="keyword">switch</span> d.Type &#123;</span><br><span class="line">		<span class="keyword">case</span> Sync, Replaced, Added, Updated:</span><br><span class="line">			s.cacheMutationDetector.AddObject(d.Object)</span><br><span class="line">			<span class="keyword">if</span> old, exists, err := s.indexer.Get(d.Object); err == <span class="literal">nil</span> &amp;&amp; exists &#123;</span><br><span class="line">				<span class="keyword">if</span> err := s.indexer.Update(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> err</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				isSync := <span class="literal">false</span></span><br><span class="line">				<span class="keyword">switch</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> d.Type == Sync:</span><br><span class="line">					<span class="comment">// Sync events are only propagated to listeners that requested resync</span></span><br><span class="line">					isSync = <span class="literal">true</span></span><br><span class="line">				<span class="keyword">case</span> d.Type == Replaced:</span><br><span class="line">					<span class="keyword">if</span> accessor, err := meta.Accessor(d.Object); err == <span class="literal">nil</span> &#123;</span><br><span class="line">						<span class="keyword">if</span> oldAccessor, err := meta.Accessor(old); err == <span class="literal">nil</span> &#123;</span><br><span class="line">							<span class="comment">// Replaced events that didn't change resourceVersion are treated as resync events</span></span><br><span class="line">							<span class="comment">// and only propagated to listeners that requested resync</span></span><br><span class="line">							isSync = accessor.GetResourceVersion() == oldAccessor.GetResourceVersion()</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				s.processor.distribute(updateNotification&#123;oldObj: old, newObj: d.Object&#125;, isSync)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> err := s.indexer.Add(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> err</span><br><span class="line">				&#125;</span><br><span class="line">				s.processor.distribute(addNotification&#123;newObj: d.Object&#125;, <span class="literal">false</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> Deleted:</span><br><span class="line">			<span class="keyword">if</span> err := s.indexer.Delete(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">			s.processor.distribute(deleteNotification&#123;oldObj: d.Object&#125;, <span class="literal">false</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然这个地方 <code>s.indexer.Add</code> 对应的是接下来的第四步， <code>distribute</code> 对应的是接下来的第六步（这个地方出现了分流）。</p>
<br/>

<h2 id="4-Add-Object"><a href="#4-Add-Object" class="headerlink" title="4) Add Object"></a>4) Add Object</h2><p>Indexer 本身是一个线程安全缓存的封装 <code>ThreadSafeMap</code> ( <code>client-go/tools/cache/thread_safe_store.go</code> )。</p>
<p>线程安全存储的结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> threadSafeMap <span class="keyword">struct</span> &#123;</span><br><span class="line">	lock  sync.RWMutex</span><br><span class="line">	items <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// indexers maps a name to an IndexFunc</span></span><br><span class="line">	indexers Indexers</span><br><span class="line">	<span class="comment">// indices maps a name to an Index</span></span><br><span class="line">	indices Indices</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>items 字段存储的是资源对象，key 是通过 keyFunc 函数 (默认为 MetaNamespaceKeyFunc) 计算得到，值用来存储资源对象；</p>
<p>indexers 与 indices 的关系如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Indexers <span class="keyword">map</span>[<span class="keyword">string</span>]IndexFunc</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IndexFunc <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">string</span>, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Indices <span class="keyword">map</span>[<span class="keyword">string</span>]Index</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Index <span class="keyword">map</span>[<span class="keyword">string</span>]sets.String</span><br></pre></td></tr></table></figure>

<ul>
<li>Indexers 为索引器，key 为索引器的名称，value 为索引函数。制定不同索引器是为了实现多样化的查询，如根据用户查询、根据某一标签查询等；</li>
<li>IndexFunc 为索引函数，定义为接收一个 Obj，返回检索结果列表；</li>
<li>Indices 为存储器，key 为存储器名称，value 为缓存数据；</li>
<li>Index 为缓存数据，结构为 K/V，sets 是利用 map 实现的一个集合结构，实现去重特性。</li>
</ul>
<br/>

<h2 id="5-Store-Object-amp-Key"><a href="#5-Store-Object-amp-Key" class="headerlink" title="5) Store Object &amp; Key"></a>5) Store Object &amp; Key</h2><p>与 4) 步可以放在一起，本质上都是 <code>ThreadSafeMap</code> 中实现。</p>
<br/>

<h2 id="6-Dispatch-Event-Handler-functions-Send-Object-to-Custom-Controller"><a href="#6-Dispatch-Event-Handler-functions-Send-Object-to-Custom-Controller" class="headerlink" title="6) Dispatch Event Handler functions (Send Object to Custom Controller)"></a>6) Dispatch Event Handler functions (Send Object to Custom Controller)</h2><p>SharedInformer 中事件的处理依赖于 <code>processorLister</code> ，其引用关系为 <code>sharedIndexInformer</code> → <code>sharedProcessor</code> → <code>processorListener</code> → <code>handler</code>.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> sharedIndexInformer <span class="keyword">struct</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	precessor *sharedProcessor</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sharedIndexInformer</code> 在 <code>HandleDeltas</code> 中根据资源对象操作的类型分别调用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> d.Type = Added, Updated:</span><br><span class="line">	<span class="keyword">if</span> old, exists, err := s.indexer.Get(d.Object), err == <span class="literal">nil</span> &amp;&amp; exists &#123;</span><br><span class="line">		s.processor.distribute(updateNotification&#123;oldObj: old, newObj: d.Object&#125;, isSync)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		s.processor.distribute(addNotification&#123;newObj: d.Object&#125;, <span class="literal">false</span>)</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">case</span> Deleted:</span><br><span class="line">	<span class="keyword">if</span> err := s.indexer.Delete(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	s.processor.distribute(deleteNotification&#123;oldObj: d.Object&#125;, <span class="literal">false</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事件类型以 Notification 的形式传递给了 <code>processorListener</code> ， <code>processorListener</code> 会根据事件类型调用不同的回调函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client-go/tools/cache/shared_informer.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *processorListener)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">	stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	wait.Until(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> next := <span class="keyword">range</span> p.nextCh &#123;</span><br><span class="line">			<span class="keyword">switch</span> notification := next.(<span class="keyword">type</span>) &#123;</span><br><span class="line">			<span class="keyword">case</span> updateNotification:</span><br><span class="line">				p.handler.OnUpdate(notification.oldObj, notification.newObj)</span><br><span class="line">			<span class="keyword">case</span> addNotification:</span><br><span class="line">				p.handler.OnAdd(notification.newObj)</span><br><span class="line">			<span class="keyword">case</span> deleteNotification:</span><br><span class="line">				p.handler.OnDelete(notification.oldObj)</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				utilruntime.HandleError(fmt.Errorf(<span class="string">"unrecognized notification: %T"</span>, next))</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// the only way to get here is if the p.nextCh is empty and closed</span></span><br><span class="line">		<span class="built_in">close</span>(stopCh)</span><br><span class="line">	&#125;, <span class="number">1</span>*time.Second, stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br/>

<h1 id="控制逻辑——以-Deployment-为例"><a href="#控制逻辑——以-Deployment-为例" class="headerlink" title="控制逻辑——以 Deployment 为例"></a>控制逻辑——以 Deployment 为例</h1><h2 id="7-Enqueue-Object-Key"><a href="#7-Enqueue-Object-Key" class="headerlink" title="7) Enqueue Object Key"></a><strong>7)</strong> Enqueue Object Key</h2><p>这里的队列逻辑就比较简单了，就在 <code>controller.go</code> (控制器) 中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DeploymentController)</span> <span class="title">enqueue</span><span class="params">(deployment *apps.Deployment)</span></span> &#123;</span><br><span class="line">	key, err := controller.KeyFunc(deployment)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">"couldn't get key for object %#v: %v"</span>, deployment, err))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dc.queue.Add(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 queue 采用的是一个限速队列:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DeploymentController <span class="keyword">struct</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// Deployments that need to be synced</span></span><br><span class="line">	queue workqueue.RateLimitingInterface</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一些其他队列的实现，都在 <code>client-go/util/workqueue/</code> 中。</p>
<br/>

<h2 id="8-Get-Key"><a href="#8-Get-Key" class="headerlink" title="8) Get Key"></a><strong>8)</strong> Get Key</h2><p><code>pkg/controller/deployment/deployment_controller.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DeploymentController)</span> <span class="title">worker</span><span class="params">()</span> &#125;</span></span><br><span class="line">  <span class="comment">// 很有意思</span></span><br><span class="line">  <span class="keyword">for</span> dc.processNextWorkItem() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DeploymentController)</span> <span class="title">processNextWorkItem</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="comment">// 从队列头部取出对象</span></span><br><span class="line">  key, quit := dc.queue.Get()</span><br><span class="line">  <span class="keyword">if</span> quit &#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> dc.queue.Done(key)</span><br><span class="line">  <span class="comment">// 处理对象</span></span><br><span class="line">  err := dc.syncHandler(key.(<span class="keyword">string</span>))</span><br><span class="line">  dc.handleErr(err, key)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Deployment controller 的 <code>worker</code> 函数不断调用 <code>processNextWorkItem</code> 函数，从 workqueue 中获取待处理的对象，如果存在，则在 <code>syncHandler</code> 中处理相应的增删改查逻辑；如果不存在，则退出。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DeploymentController)</span> <span class="title">syncDeployment</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		namespace, name, err := cache.SplitMetaNamespaceKey(key)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				klog.ErrorS(err, <span class="string">"Failed to split meta namespace cache key"</span>, <span class="string">"cacheKey"</span>, key)</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		startTime := time.Now()</span><br><span class="line">		klog.V(<span class="number">4</span>).InfoS(<span class="string">"Started syncing deployment"</span>, <span class="string">"deployment"</span>, klog.KRef(namespace, name), <span class="string">"startTime"</span>, startTime)</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				klog.V(<span class="number">4</span>).InfoS(<span class="string">"Finished syncing deployment"</span>, <span class="string">"deployment"</span>, klog.KRef(namespace, name), <span class="string">"duration"</span>, time.Since(startTime))</span><br><span class="line">		&#125;()</span><br><span class="line">	</span><br><span class="line">		deployment, err := dc.dLister.Deployments(namespace).Get(name)</span><br><span class="line">		<span class="keyword">if</span> errors.IsNotFound(err) &#123;</span><br><span class="line">				klog.V(<span class="number">2</span>).InfoS(<span class="string">"Deployment has been deleted"</span>, <span class="string">"deployment"</span>, klog.KRef(namespace, name))</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// Deep-copy otherwise we are mutating our cache.</span></span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> Deep-copy only when needed.</span></span><br><span class="line">		d := deployment.DeepCopy()</span><br><span class="line">	</span><br><span class="line">		everything := metav1.LabelSelector&#123;&#125;</span><br><span class="line">		<span class="keyword">if</span> reflect.DeepEqual(d.Spec.Selector, &amp;everything) &#123;</span><br><span class="line">				<span class="comment">// deployment 必须包含 selector 标签</span></span><br><span class="line">				dc.eventRecorder.Eventf(d, v1.EventTypeWarning, <span class="string">"SelectingAll"</span>, <span class="string">"This deployment is selecting all pods. A non-empty selector is required."</span>)</span><br><span class="line">				<span class="keyword">if</span> d.Status.ObservedGeneration &lt; d.Generation &#123;</span><br><span class="line">						d.Status.ObservedGeneration = d.Generation</span><br><span class="line">						dc.client.AppsV1().Deployments(d.Namespace).UpdateStatus(context.TODO(), d, metav1.UpdateOptions&#123;&#125;)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// List ReplicaSets owned by this Deployment, while reconciling ControllerRef</span></span><br><span class="line">		<span class="comment">// through adoption/orphaning.</span></span><br><span class="line">		<span class="comment">// 获取 deployment 所控制的 replicaSet</span></span><br><span class="line">		rsList, err := dc.getReplicaSetsForDeployment(d)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// List all Pods owned by this Deployment, grouped by their ReplicaSet.</span></span><br><span class="line">		<span class="comment">// Current uses of the podMap are:</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// * check if a Pod is labeled correctly with the pod-template-hash label.</span></span><br><span class="line">		<span class="comment">// * check that no old Pods are running in the middle of Recreate Deployments.</span></span><br><span class="line">		podMap, err := dc.getPodMapForDeployment(d, rsList)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">if</span> d.DeletionTimestamp != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> dc.syncStatusOnly(d, rsList)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Update deployment conditions with an Unknown condition when pausing/resuming</span></span><br><span class="line">		<span class="comment">// a deployment. In this way, we can be sure that we won't timeout when a user</span></span><br><span class="line">		<span class="comment">// resumes a Deployment with a set progressDeadlineSeconds.</span></span><br><span class="line">		<span class="keyword">if</span> err = dc.checkPausedConditions(d); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">if</span> d.Spec.Paused &#123;</span><br><span class="line">				<span class="keyword">return</span> dc.sync(d, rsList)</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// rollback is not re-entrant in case the underlying replica sets are updated with a new</span></span><br><span class="line">		<span class="comment">// revision so we should ensure that we won't proceed to update replica sets until we</span></span><br><span class="line">		<span class="comment">// make sure that the deployment has cleaned up its rollback spec in subsequent enqueues.</span></span><br><span class="line">		<span class="comment">// 判断 deployment 事件是否是一个回滚事件</span></span><br><span class="line">		<span class="comment">// 回滚状态发生后，为了防止底层 replicaset 被新版本更新，此时回滚状态不能被重新进入</span></span><br><span class="line">		<span class="comment">// 直到确认 deployment 在后续队列中清除了 rollback spec</span></span><br><span class="line">		<span class="keyword">if</span> getRollbackTo(d) != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> dc.rollback(d, rsList)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 判断本次 deployment 是否是一个 scale 事件</span></span><br><span class="line">		scalingEvent, err := dc.isScalingEvent(d, rsList)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> scalingEvent &#123;</span><br><span class="line">				<span class="keyword">return</span> dc.sync(d, rsList)</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 更新策略决定如何更新</span></span><br><span class="line">		<span class="keyword">switch</span> d.Spec.Strategy.Type &#123;</span><br><span class="line">		<span class="keyword">case</span> apps.RecreateDeploymentStrategyType:</span><br><span class="line">				<span class="keyword">return</span> dc.rolloutRecreate(d, rsList, podMap)</span><br><span class="line">		<span class="keyword">case</span> apps.RollingUpdateDeploymentStrategyType:</span><br><span class="line">				<span class="keyword">return</span> dc.rolloutRolling(d, rsList)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"unexpected deployment strategy type: %s"</span>, d.Spec.Strategy.Type)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>syncDeployment</code> 方法中先后调用了 deployment、replicaset、pod 的 Lister，获取资源的状态信息，根据状态的不同，采取不同的控制逻辑，这里先暂时忽略具体控制逻辑部分的代码，这部分对应的是图中 <code>Handle Object</code> </p>
<p><a href="https://www.notion.so/Deployment-e17ff7e096de4f94b8fa6a01347bfb7b">Deployment 如何做到滚动更新</a></p>
</div><div class="article-tags size-small is-uppercase mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Kubernetes/">Kubernetes</a><a class="link-muted mr-2" rel="tag" href="/tags/Operators/">Operators</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/02/18/Kube-Controller/"><span class="level-item">Kubernetes Controller</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3 is-sticky"><div class="card widget" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex" href="#启动控制器"><span class="mr-2">1</span><span>启动控制器</span></a></li><li><a class="is-flex" href="#构建控制器"><span class="mr-2">2</span><span>构建控制器</span></a></li><li><a class="is-flex" href="#Client-go"><span class="mr-2">3</span><span>Client-go</span></a><ul class="menu-list"><li><a class="is-flex" href="#1-List-amp-Watch"><span class="mr-2">3.1</span><span>1) List &amp;amp; Watch</span></a></li><li><a class="is-flex" href="#2-Add-Object"><span class="mr-2">3.2</span><span>2) Add Object</span></a></li><li><a class="is-flex" href="#3-Pop-Object"><span class="mr-2">3.3</span><span>3) Pop Object</span></a></li><li><a class="is-flex" href="#4-Add-Object"><span class="mr-2">3.4</span><span>4) Add Object</span></a></li><li><a class="is-flex" href="#5-Store-Object-amp-Key"><span class="mr-2">3.5</span><span>5) Store Object &amp;amp; Key</span></a></li><li><a class="is-flex" href="#6-Dispatch-Event-Handler-functions-Send-Object-to-Custom-Controller"><span class="mr-2">3.6</span><span>6) Dispatch Event Handler functions (Send Object to Custom Controller)</span></a></li></ul></li><li><a class="is-flex" href="#控制逻辑——以-Deployment-为例"><span class="mr-2">4</span><span>控制逻辑——以 Deployment 为例</span></a><ul class="menu-list"><li><a class="is-flex" href="#7-Enqueue-Object-Key"><span class="mr-2">4.1</span><span>7) Enqueue Object Key</span></a></li><li><a class="is-flex" href="#8-Get-Key"><span class="mr-2">4.2</span><span>8) Get Key</span></a></li></ul></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2021-05-02T14:53:42.000Z">2021-05-02</time></p><p class="title is-6"><a class="link-muted" href="/2021/05/02/Controller%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Controller 源码分析</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Deployments/">Deployments</a> / <a class="link-muted" href="/categories/Deployments/Kubernetes/">Kubernetes</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2021-02-18T12:29:26.000Z">2021-02-18</time></p><p class="title is-6"><a class="link-muted" href="/2021/02/18/Kube-Controller/">Kubernetes Controller</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Development/">Development</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2021-01-31T07:29:26.000Z">2021-01-31</time></p><p class="title is-6"><a class="link-muted" href="/2021/01/31/PacketPickOnK8s/">Kubernetes 抓包</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Operations/">Operations</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2021-01-18T04:39:26.000Z">2021-01-18</time></p><p class="title is-6"><a class="link-muted" href="/2021/01/18/Docker%E9%95%9C%E5%83%8F%E4%BB%A3%E7%90%86/">Docker镜像代理</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Operations/">Operations</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-10-08T08:51:10.000Z">2020-10-08</time></p><p class="title is-6"><a class="link-muted" href="/2020/10/08/OpenstackCinderCSIPlugin/">Kubernetes 使用 Openstack Cinder 作为存储后端</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Kubernetes/">Kubernetes</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Fusidic&#039;s blog" height="28"></a><p class="size-small"><span>&copy; 2021 arithbar</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://fusidic.github.io',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>