<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Microservices in Golang - Part2 - Fusidic&#039;s blog</title><meta description="内容提要：Docker &amp;amp; Go-Micro 原作者：Ewan Valentine 原文链接：https:&amp;#x2F;&amp;#x2F;ewanvalentine.io&amp;#x2F;microservices-in-golang-part-2&amp;#x2F; 引言在上篇文章中，我们介绍了编写基于gRPC的微服务的基础知识，在这一部分我们将介绍Docker化服务(Dockerising a service) 的相关知识，同时我们也会在程序中使"><meta property="og:type" content="blog"><meta property="og:title" content="Microservices in Golang - Part2"><meta property="og:url" content="https://fusidic.github.io/"><meta property="og:site_name" content="Fusidic&#039;s blog"><meta property="og:description" content="内容提要：Docker &amp;amp; Go-Micro 原作者：Ewan Valentine 原文链接：https:&amp;#x2F;&amp;#x2F;ewanvalentine.io&amp;#x2F;microservices-in-golang-part-2&amp;#x2F; 引言在上篇文章中，我们介绍了编写基于gRPC的微服务的基础知识，在这一部分我们将介绍Docker化服务(Dockerising a service) 的相关知识，同时我们也会在程序中使"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2020-04-08T14:34:08.000Z"><meta property="article:modified_time" content="2020-05-20T11:03:02.000Z"><meta property="article:author" content="arithbar"><meta property="article:tag" content="Golang"><meta property="article:tag" content="Microservices"><meta property="article:tag" content="Translation"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://fusidic.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://fusidic.github.io/2020/04/08/MicroservicesinGolangPart2/"},"headline":"Fusidic's blog","image":["https://fusidic.github.io/img/og_image.png"],"datePublished":"2020-04-08T14:34:08.000Z","dateModified":"2020-05-20T11:03:02.000Z","author":{"@type":"Person","name":"arithbar"},"description":"内容提要：Docker &amp; Go-Micro 原作者：Ewan Valentine 原文链接：https:&#x2F;&#x2F;ewanvalentine.io&#x2F;microservices-in-golang-part-2&#x2F; 引言在上篇文章中，我们介绍了编写基于gRPC的微服务的基础知识，在这一部分我们将介绍Docker化服务(Dockerising a service) 的相关知识，同时我们也会在程序中使"}</script><link rel="canonical" href="https://fusidic.github.io/2020/04/08/MicroservicesinGolangPart2/"><link rel="icon" href="/img/favicon.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Fusidic&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/fusidic"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-04-08T14:34:08.000Z" title="2020-04-08T14:34:08.000Z">2020-04-08</time><span class="level-item"><a class="link-muted" href="/categories/Developments/">Developments</a><span> / </span><a class="link-muted" href="/categories/Developments/Microservices/">Microservices</a></span><span class="level-item">39 分钟 读完 (大约 5867 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Microservices in Golang - Part2</h1><div class="content"><p>内容提要：Docker &amp; Go-Micro</p>
<p>原作者：Ewan Valentine</p>
<p>原文链接：<a href="https://ewanvalentine.io/microservices-in-golang-part-2/">https://ewanvalentine.io/microservices-in-golang-part-2/</a></p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在<a href="https://fusidic.github.io/2020/04/07/MicroservicesinGolangPart1/">上篇文章</a>中，我们介绍了编写基于gRPC的微服务的基础知识，在这一部分我们将介绍<strong>Docker化服务</strong>(Dockerising a service) 的相关知识，同时我们也会在程序中使用 <strong>go-micro</strong> 以替代 gRPC ( go-micro 中也对 gRPC 进行了封装)，最后引入第二个服务。</p>
<a id="more"></a>

  <br/>

<h2 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h2><p>随着云计算的出现和微服务的诞生，通常我们需要一次部署更多更小的代码块，这给我们服务部署的工作带来了很大的压力，但也因而产生了很多有趣的思路和技术——其中有个很重要的概念就是<a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization">容器</a>。</p>
<p>传统的部署方案中，运维团队会将应用整体部署到运行特定操作系统的静态服务器上，或者也许是部署在Chef或者Puppet提供的虚拟机上。在这些场景中，应用扩展需要付出昂贵的代价，并且效率也不尽如人意。最常见的选择是垂直扩展——给静态服务器配置更多的资源。</p>
<p>之后诸如 <a href="https://www.vagrantup.com/">vagrant</a> 之类的工具应运而生，使得配置VM变得相当简单。但是运行一台虚拟机仍然是一项相当繁重的操作：要知道，你是在宿主机中运行的是具有所有功能、内核及其他配置的完整的操作系统。在资源方面，VM的代价是很高的，所以当微服务面世的时候，在多个VM环境中运行单独的代码库显然是不可行的。</p>
<br/>

<h2 id="直到容器出现"><a href="#直到容器出现" class="headerlink" title="直到容器出现"></a>直到容器出现</h2><p><a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization">容器</a>是精简版的操作系统，但容器并不包括内核、访客系统及其他任何更底层的操作系统的基础结构。</p>
<p>容器只包含高层的库和运行时 (Run-time) 组件，容器共享宿主机的内核，因此Unix内核只在宿主机上运行，并被很多个具有不同运行时的容器共享。</p>
<p>在底层，容器利用内核提供的不同功能，以便在容器空间中共享资源和网络功能。</p>
<p><em><a href="https://www.redhat.com/en/topics/containers/whats-a-linux-container">Further reading</a></em></p>
<p>这意味着你并不需要启动好几个完整的操作系统，就可以运行代码所需要的运行时和依赖库。容器改变了游戏规则，和VM相比容器的整体大小要小得多。以Ubuntu为例，最小的版本也有接近1GB大小，而相较之下Docker镜像可以仅仅只有188MB。</p>
<p>你可能会注意到我提到更多的是“容器”，而不是 <a href="https://www.docker.com/">Docker</a>。事实上Docker与容器其实就是一个东西，但是容器更多的是Linux中的概念或功能集，<a href="https://www.docker.com/">Docker</a>则是容器技术的一种实现，由于其易用性而变得流行，当然容器技术也有<a href="https://www.contino.io/insights/beyond-docker-other-types-of-containers">其他实现</a>。之后的内容我们依然还是使用Docker，我认为它能提供最好的支持，而且对新手来说也是最友好的。</p>
<br/>

<p>相信到现在你已经充分了解到容器化技术的价值了，那么就让我们开始把第一个服务容器化吧。第一步是创建一个Dockerfile  <code>$ touch consignment-service/Dockerfile</code>.</p>
<p>在里面加上以下内容：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:alpine as builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk update &amp;&amp; apk upgrade &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apk add --no-cache git</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> GO111MODULE=on</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> go mod download</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o consignment-service</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Run container</span></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk --no-cache add ca-certificates</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder /app/consignment-service .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"./consignment-service"</span>]</span></span><br></pre></td></tr></table></figure>

<br/>

<p>所以这几行代码干了什么？我们现在正在使用的是所谓的多阶段dockerfile (Multi-stage Build Dockerfile)，它允许我们使用单独的docker镜像来构建和运行容器。当我们构建容器时，构建的第一个容器会使用Golang runtime作为基础镜像，引入我们需要的依赖项，接着生成我们需要的二进制文件。Dockerfile的第二部分 (也就是我留下“Run container”注释的下方) ，从build容器中得到二进制文件 (由于两个容器可以隐式地共享状态和产物，因此Alpine镜像可以在没有Golang运行时的情况下运行我们的二进制文件，这意味着二进制文件中就已经包括了所有用于连接网络和执行文件所需的依赖，这意味着我们的容器可以做到更小。更小的容器意味着更快的部署、更快的扩容以及更小的空间占用)</p>
<p><a href="https://docs.docker.com/engine/userguide/eng-image/multistage-build/#name-your-build-stages">更多关于分阶段构建容器的细节</a></p>
<p>如果你使用Linux运行Alpine，你可能会碰到一些问题。因此如果你是在Linux平台上学习本教程，你可以直接将 <code>alpine</code> 更换成 <code>debian</code> ，那样应该就没什么问题了。之后我们会用到一种更好的方式来编译二进制文件。</p>
<p>接下来可以使用如下指令构建Docker镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t consignment-service .</span><br></pre></td></tr></table></figure>

<blockquote>
<p>编者注：</p>
<p>也可以直接在<code>Makefile</code>中加入：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">build:</span></span><br><span class="line">    ... </span><br><span class="line">    GOOS=linux GOARCH=amd64 go build</span><br><span class="line">    docker build -t consignment-service .</span><br></pre></td></tr></table></figure>

<p>并使用 <code>make build</code> 编译</p>
</blockquote>
<p>使用如下指令运行这个镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 50051:50051 consignment-service</span><br></pre></td></tr></table></figure>

<p><code>-p</code> 标志着一个端口映射，意味着将容器的 <code>50051</code> 端口映射到宿主机的 <code>50051</code> 端口上。我们也可以修改一下这个映射，将容器端口绑定到宿主机其他端口上，比如 <code>8080:50051</code> ，就意味着在本地 <code>8080</code> 上接收请求。</p>
<p><a href="https://docs.docker.com/engine/userguide/networking/">你可以通过这篇文章了解Docker网络工作的原理</a>.</p>
<p>使用以上命令创建docker镜像并且运行它，之后在另一个终端面板中，运行你的cli客户端 <code>$ go run cli.go</code> ，再次确认容器能够正常工作。</p>
<br/>

<p>当你使用 <code>$ docker build</code> 的时候，此时将你的代码和运行时环境都编译到了一个镜像里面，Docker 镜像是你的环境以及依赖项的一个“快照”，你可以通过将 Docker 镜像发布到 Docker Hub 来分享出去。Docker Hub有些类似 npm、yum 这样的包管理仓库，它存放的是 docker 镜像文件。当你在 <code>Dockerfile</code> 中定义了一个 <code>From</code> 的时候，就会告知 docker 程序从远程 Docker Hub 中拉取所需要的镜像作为基础镜像，然后可以通过重定义的方式扩展或者覆盖基础镜像中的内容。现在你就可以去 <a href="https://hub.docker.com/explore/">docker hub</a> 上看一下，你会发现很多软件其实都已经被容器化了，看<a href="https://www.youtube.com/watch?v=GsLZz8cZCzc">这个视频</a>你会发现容器化有多么美妙！</p>
<p>Dockerfile 中的声明会在它第一次构建时被缓存，这大大节省了你作出修改后，重新编译整个运行环境所需要消耗的时间。 Docker 非常智能，它能知道那个地方被修改了，那个地方需要被重新编译，这一切使得编译工作变得非常之快。</p>
<p>关于容器就说到这了，让我们回到代码部分！</p>
<br/>

<h2 id="回到代码"><a href="#回到代码" class="headerlink" title="回到代码"></a>回到代码</h2><p>当我们创建gRPC服务的时候，有很多用于创建网络连接的模版代码 (Boilerplate)，你必须将服务的地址的位置 (Hard-code, 硬编码) 到客户端或者其他服务中，才能使其连接到相应的地址 (比如在客户端中写死远端服务器的地址和端口，又或者一个微服务将另一个微服务的地址和端口写死)。这是一个非常麻烦的问题，特别是当你在云中运行了很多的微服务，这些微服务可能不在同一台主机上，又或者它们的地址可能会在重部署之后发生改变。</p>
<p>这就到了<strong>服务发现(Service Discovery)</strong>大显身手的时候了。服务发现会保留所有服务的信息以及它们的地址，并实时更新。每个服务在开始运行的时候都会想“服务发现”程序注册，在服务关闭的时候向其注销，每一个服务都会有一个名称或者id唯一标记它，所以就算它换了一个新的IP地址或者主机地址，只要服务名还保持一样，你就不需要在你的程序中修改相应的调用代码。</p>
<p>当然了，其实还有其他方法可以解决这个问题，但正像编程界的其他技术一样，如果已经有人提出了一个方法处理问题，那么就不必重复造轮子了 :) . 已经有人足够清晰的解决了这个问题，且方案非常简单，他就是 @chuhnk (Asim Aslam)，<a href="https://micro.mu/">Go-micro </a>的开发者。Go-Micro 是一个非常可靠的 Go 语言微服务框架，现在拥有一个完整的团队，发展非常迅速，并得到了一些知名人士的支持。</p>
<br/>

<h2 id="Go-micro"><a href="#Go-micro" class="headerlink" title="Go-micro"></a>Go-micro</h2><p>Go-micro 拥有许多用于构建基于 Go 的微服务的强大功能，我们这里要用到的就是它所提供的服务发现的功能。为了使用Go-micro，我们需要修改服务中的一些代码，以下使用 Go-micro 作为 protoc 插件，替换掉正在使用的标准 gRPC 插件。</p>
<p><em>首先确保安装了 go-micro 依赖：</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get -u github.com/micro/protobuf/&#123;proto,protoc-gen-go&#125;</span><br></pre></td></tr></table></figure>

<p>换用go-micro作为插件重新生成proto的代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ protoc -I. --go_out=plugins=micro:. \</span><br><span class="line">		proto/consignment/consignment.proto</span><br></pre></td></tr></table></figure>

<p>现在为了使用go-micro我们需要更新 <code>consignment-service/main.go</code> 中的一些内容，通过抽象出我们之前的gRPC 代码，go-micro 可以轻松的注册和扩展我们的服务。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shippy-service-consignment/main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Import the generated protobuf code</span></span><br><span class="line">	pb <span class="string">"github.com/&lt;YourUsername&gt;/consignment-service/proto/consignment"</span></span><br><span class="line">	<span class="string">"github.com/micro/go-micro"</span></span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> repository <span class="keyword">interface</span> &#123;</span><br><span class="line">	Create(*pb.Consignment) (*pb.Consignment, error)</span><br><span class="line">	GetAll() []*pb.Consignment</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Repository - Dummy repository, this simulates the use of a datastore</span></span><br><span class="line"><span class="comment">// of some kind. We'll replace this with a real implementation later on.</span></span><br><span class="line"><span class="keyword">type</span> Repository <span class="keyword">struct</span> &#123;</span><br><span class="line">	consignments []*pb.Consignment</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(repo *Repository)</span> <span class="title">Create</span><span class="params">(consignment *pb.Consignment)</span> <span class="params">(*pb.Consignment, error)</span></span> &#123;</span><br><span class="line">	updated := <span class="built_in">append</span>(repo.consignments, consignment)</span><br><span class="line">	repo.consignments = updated</span><br><span class="line">	<span class="keyword">return</span> consignment, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(repo *Repository)</span> <span class="title">GetAll</span><span class="params">()</span> []*<span class="title">pb</span>.<span class="title">Consignment</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> repo.consignments</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Service 需要实现在proto中定义的所有方法。当你不确定时</span></span><br><span class="line"><span class="comment">// 可以去对应的*.pb.go文件里查看需要实现的方法及其定义</span></span><br><span class="line"><span class="keyword">type</span> service <span class="keyword">struct</span> &#123;</span><br><span class="line">	repo repository</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateConsignment - 在proto中，我们给这个微服务定了两个方法，其中之</span></span><br><span class="line"><span class="comment">// 一就是这个CreateConsignment方法，它接受一个context以及proto中定义</span></span><br><span class="line"><span class="comment">// 的Consignment消息，这个Consignment是由gRPC的服务器处理后提供给你的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *service)</span> <span class="title">CreateConsignment</span><span class="params">(ctx context.Context, req *pb.Consignment, res *pb.Response)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Save our consignment</span></span><br><span class="line">	consignment, err := s.repo.Create(req)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Return matching the `Response` message we created in our</span></span><br><span class="line">	<span class="comment">// protobuf definition.</span></span><br><span class="line">	res.Created = <span class="literal">true</span></span><br><span class="line">	res.Consignment = consignment</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// GetConsignments</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *service)</span> <span class="title">GetConsignments</span><span class="params">(ctx context.Context, req *pb.GetRequest, res *pb.Response)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	consignments := s.repo.GetAll()</span><br><span class="line">	res.Consignments = consignments</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	repo := &amp;Repository&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create a new service. Optionally include some options here.</span></span><br><span class="line">	srv := micro.NewService(</span><br><span class="line"></span><br><span class="line">		<span class="comment">// This name must match the package name given in your protobuf definition</span></span><br><span class="line">		<span class="comment">// 注意：服务名必须和你在proto文件中定义的package名字相同</span></span><br><span class="line">    <span class="comment">// micro.Name("go.micro.srv.consignment"),</span></span><br><span class="line">		micro.Name(<span class="string">"consignment"</span>),</span><br><span class="line">    micro.Version(<span class="string">"latest"</span>),</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Init will parse the command line flags.</span></span><br><span class="line">	srv.Init()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register handler</span></span><br><span class="line">	pb.RegisterShippingServiceHandler(srv.Server(), &amp;service&#123;repo&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Run the server</span></span><br><span class="line">	<span class="keyword">if</span> err := srv.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br/>

<p>主要的改动发生在 gRPC 服务器创建的这个部分，这一部分内容中用 <code>micro.NewService()</code> 方法将原本的流程进行了抽象，用于注册我们的服务。最后 <code>service.Run()</code> 方法处理了服务的连接，一如之前，我们将接口方法的实现进行注册，只不过这次用了一些不同的方法。</p>
<blockquote>
<p>编者注：</p>
<p>我们将gRPC的服务调用与go-micro服务调用对比</p>
<p>gRPC:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">repo := &amp;Repository&#123;&#125;</span><br><span class="line"></span><br><span class="line">srv := micro.NewService(</span><br><span class="line">	micro.Name(<span class="string">"consignment"</span>),</span><br><span class="line">   micro.Version(<span class="string">"latest"</span>),</span><br><span class="line">)</span><br><span class="line">srv.Init()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register handler</span></span><br><span class="line">pb.RegisterShippingServiceHandler(srv.Server(), &amp;service&#123;repo&#125;)</span><br></pre></td></tr></table></figure>

<p>go-micro:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">repo := &amp;Repository&#123;&#125;</span><br><span class="line"></span><br><span class="line">lis, err := net.Listen(<span class="string">"tcp"</span>, port)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatalf(<span class="string">"failed to listen: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">s := grpc.NewServer()</span><br><span class="line"></span><br><span class="line">pb.RegisterShippingServiceServer(s, &amp;service&#123;repo&#125;)</span><br></pre></td></tr></table></figure>

<p>其实这里go-micro做了一个从服务名到地址的封装。</p>
</blockquote>
<br/>

<p>另一个重要的改动发生在服务方法本身，方法参数和返回值的类型发生了一些变化，go-micro 统一了原来 gRPC 中四种不同的方法声明的接口，将其统一抽象为 <code>req</code> 和 <code>res</code> ，并将请求和返回的结构体都作为了参数，只返回一个错误信息。在这个方法之中，我们设置的返回值由go-micro进行处理。</p>
<p>最后我们不再将端口部分写死，而是采用服务名 <code>micro.Name(&quot;cnosignment&quot;)</code>来调用服务，go-micro中使用环境变量或者通过命令行输入来设置地址，如 <code>MICRO_SERVER_ADDRESS=:50051</code>。</p>
<blockquote>
<p>编者注：</p>
<p><strong><code>micro.Name()</code> 中的服务名一定要和 proto 文件中定义的 package 名字相同</strong></p>
<p>Makefile:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">run:</span></span><br><span class="line"> docker run -p 50051:50051 \</span><br><span class="line">     -e MICRO_SERVER_ADDRESS=:50051 \</span><br><span class="line">     -e MICRO_REGISTRY=mdns consignment-service</span><br></pre></td></tr></table></figure>


</blockquote>
<p>默认情况下，Go-micro使用 “多播 dns” (<a href="https://en.wikipedia.org/wiki/Multicast_DNS">mdns</a>, multicast dns) 作为本地服务发现代理供本地使用。您可能不会在生产环境中使用这个，但我们这里仅仅只是为了测试，所以就不用在本地运行像 Consul 或者 etcd 这样的服务了，之后的文章会讲到关于它们的内容的。</p>
<br/>

<p>现在我们需要做的事情就是将环境变量传入容器中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 50051:50051 \</span><br><span class="line">      -e MICRO_SERVER_ADDRESS=:50051 \</span><br><span class="line">      consignment-service</span><br></pre></td></tr></table></figure>

<p><code>-e</code>是一个环境变量的标志，允许我们将环境变量传递到Docker容器中，每个标志只能对应一个变量，比如 <code>-e ENV=staging -e DB_HOST=localhost</code> 等。</p>
<p>现在我们就有了一个容器化的服务了，并且用到了服务发现。所以接下来更新我们的CLI工具：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    ...</span><br><span class="line">    micro <span class="string">"github.com/micro/go-micro"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 使用go-micro构建服务consignment.cli</span></span><br><span class="line">	service := micro.NewService(micro.Name(<span class="string">"consignment.cli"</span>))</span><br><span class="line">	service.Init()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 向consignment服务器注册服务consignment.cli</span></span><br><span class="line">	client := pb.NewShippingServiceClient(<span class="string">"consignment"</span>, service.Client())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/EwanValentine/shippy-cli-consignment/blob/master/main.go">在这里查看完整的文件</a></p>
<p>我们新创建的客户端中引入了go-micro库，并使用go-micro客户端代码代替了现有的建立网络连接的代码，该代码使用服务解析而不是直接连接到地址。</p>
<br/>

<p>好吧，其实直到现在CLI还是正常工作，这是由于我们的服务运行在 Docker 中，使用的是它自己的 <a href="https://en.wikipedia.org/wiki/Multicast_DNS">mdns</a> (多播DNS)，这与我们正在使用的宿主机的 mdns 是不同的。修复这个问题最简单的方法就是让服务端和客户端都容器化，这样它们就都在同一个宿主机上运行，共用一个网络层了。接着运行下面的指令吧：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t consignment-cli .</span><br><span class="line">$ docker run consignment-cli</span><br></pre></td></tr></table></figure>

<p>为我们的客户端再写一个 <code>Dockerfile</code>:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:alpine as builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk update &amp;&amp; apk upgrade &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apk add --no-cache git</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> go get</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o consignment-cli</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk --no-cache add ca-certificates</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> consignment.json /app/consignment.json</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder /app/consignment-cli .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"./consignment-cli"</span>]</span></span><br></pre></td></tr></table></figure>

<p>这个和我们之前服务端的Dockerfile非常像，除了在最后我们将json文件传了进去。</p>
<p>现在我们就可以运行这个镜像了，请先确保你的consignment镜像已经在运行了。和之前一样，可以看到 <code>Created: true</code> 的信息。</p>
<br/>

<h2 id="Vessel-service-船只管理服务"><a href="#Vessel-service-船只管理服务" class="headerlink" title="Vessel service (船只管理服务)"></a>Vessel service (船只管理服务)</h2><p>现在让我们开始创建第二个服务。现在我们已经有了一个托运服务 (consignment service)，它会将最适合货物托运的集装箱和船只匹配起来，我们需要将集装箱 (container) 的重量和数量发送到船只服务 (vessel) 中，后者将会找到合适的船托运这些货物。</p>
<h3 id="protobuf"><a href="#protobuf" class="headerlink" title="protobuf"></a>protobuf</h3><p>接下来就创建一个新的项目 <code>vessel-service</code> ，配置和Dockerfile之前的设置一样，<code>$ mkdir -p vessel-service/proto/vessel</code>，并新建一个protobuf文件 <code>vessel-service/proto/vessel/vessel.proto</code>:</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vessel-service/proto/vessel/vessel.proto</span></span><br><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> vessel;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">VesselService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> FindAvailable(Specification) <span class="keyword">returns</span> (Response) &#123;&#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">message Vessel &#123;</span></span><br><span class="line"><span class="function">  string id = 1</span>;</span><br><span class="line">  <span class="built_in">int32</span> capacity = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">int32</span> max_weight = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">4</span>;</span><br><span class="line">  <span class="built_in">bool</span> available = <span class="number">5</span>;</span><br><span class="line">  <span class="built_in">string</span> owner_id = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Specification</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int32</span> capacity = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">int32</span> max_weight = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Response</span> </span>&#123;</span><br><span class="line">  Vessel vessel = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">repeated</span> Vessel vessels = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如你所见，和 <code>consignment-service</code> 中的 proto 文件非常像。我们可以创建一个具有单个方法 <code>FindAvailable</code>的服务，需要一个<code>Specification</code>类型的参数，并返回 <code>Response</code>类型，<code>Response</code>类型返回单个或多个<code>Vessel</code>类型 (使用 <code>repeated</code> 类型)。</p>
<br/>

<p>创建一个 <code>vessel-service/Makefile</code> 来记录编译流程和执行流程：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">build:</span></span><br><span class="line">	protoc -I. --go_out=plugins=micro:<span class="variable">$(GOPATH)</span>/src/github.com/EwanValentine/shippy/vessel-service \</span><br><span class="line">    proto/vessel/vessel.proto</span><br><span class="line">	docker build -t vessel-service .</span><br><span class="line"><span class="section">run:</span></span><br><span class="line">	docker run -p 50052:50051 -e MICRO_SERVER_ADDRESS=:50051 -e MICRO_REGISTRY=mdns vessel-service</span><br></pre></td></tr></table></figure>

<p>与 <code>consignment-service/Makefile&quot;</code> 中唯一不同的地方就是，我们需要确保容器在宿主机上使用与之前不一样的端口。</p>
<br/>

<h3 id="main-go"><a href="#main-go" class="headerlink" title="main.go"></a>main.go</h3><p>最后我们可以开始实现方法了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vessel-service/main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">	pb <span class="string">"github.com/&lt;YourUsername&gt;/vessel-service/proto/vessel"</span></span><br><span class="line">	<span class="string">"github.com/micro/go-micro"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> repository <span class="keyword">interface</span> &#123;</span><br><span class="line">	FindAvailable(*pb.Specification) (*pb.Vessel, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> VesselRepository <span class="keyword">struct</span> &#123;</span><br><span class="line">	vessels []*pb.Vessel</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FindAvailable - 根据规格清单检查船只，从货船列表中找到一个容量和载重量都符合标准的船</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(repo *VesselRepository)</span> <span class="title">FindAvailable</span><span class="params">(spec *pb.Specification)</span> <span class="params">(*pb.Vessel, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, vessel := <span class="keyword">range</span> repo.vessels &#123;</span><br><span class="line">		<span class="keyword">if</span> spec.Capacity &lt;= vessel.Capacity &amp;&amp; spec.MaxWeight &lt;= vessel.MaxWeight &#123;</span><br><span class="line">			<span class="keyword">return</span> vessel, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"No vessel found by that spec"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Our grpc service handler</span></span><br><span class="line"><span class="keyword">type</span> service <span class="keyword">struct</span> &#123;</span><br><span class="line">	repo repository</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FindAvailable 对repo.FindAvailable()的一层封装，修改了返回格式，将</span></span><br><span class="line"><span class="comment">// context, request, response三者统一</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *service)</span> <span class="title">FindAvailable</span><span class="params">(ctx context.Context, req *pb.Specification, res *pb.Response)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Find the next available vessel</span></span><br><span class="line">	vessel, err := s.repo.FindAvailable(req)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将匹配的船只写入到返回消息中</span></span><br><span class="line">	res.Vessel = vessel</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	vessels := []*pb.Vessel&#123;</span><br><span class="line">		&amp;pb.Vessel&#123;Id: <span class="string">"vessel001"</span>, Name: <span class="string">"Boaty McBoatface"</span>, MaxWeight: <span class="number">200000</span>, Capacity: <span class="number">500</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	repo := &amp;VesselRepository&#123;vessels&#125;</span><br><span class="line"></span><br><span class="line">	srv := micro.NewService(</span><br><span class="line">		micro.Name(<span class="string">"vessel"</span>),</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	srv.Init()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将接口与我们的实现绑定，将以实现的服务接口注册到Server上</span></span><br><span class="line">	pb.RegisterVesselServiceHandler(srv.Server(), &amp;service&#123;repo&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := srv.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br/>

<p>好的，这里顺便把 <code>vessel-service/Dockerfile</code> 编辑一下，和之前的几乎一样：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:alpine as builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk update &amp;&amp; apk upgrade &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apk add --no-cache git</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> GO111MODULE=on</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> go mod download</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o vessel-service</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Run container</span></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk --no-cache add ca-certificates</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder /app/vessel-service .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"./vessel-service"</span>]</span></span><br></pre></td></tr></table></figure>

<br/>

<h3 id="consigment-service"><a href="#consigment-service" class="headerlink" title="consigment-service"></a>consigment-service</h3><p>接下来就是有趣的地方了，我们需要<strong>修改货运服务</strong> ( <code>consignment-service/main.go</code> ) 以使得前者可以调用货船服务 (vessel-service)：找到适合的船、更新 <code>vessel_id</code> 等：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// consignment-service/main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line">	pb <span class="string">"github.com/&lt;YourUsername&gt;/consignment-service/proto/consignment"</span></span><br><span class="line">	vesselProto <span class="string">"github.com/&lt;YourUsername&gt;/vessel-service/proto/vessel"</span></span><br><span class="line">	<span class="string">"github.com/micro/go-micro"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	port = <span class="string">":50051"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> repository <span class="keyword">interface</span> &#123;</span><br><span class="line">	Create(*pb.Consignment) (*pb.Consignment, error)</span><br><span class="line">	GetAll() []*pb.Consignment</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Repository - 暂时假装一个数据库</span></span><br><span class="line"><span class="keyword">type</span> Repository <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu           sync.RWMutex</span><br><span class="line">	consignments []*pb.Consignment</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create 创建一个新的consignment</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(repo *Repository)</span> <span class="title">Create</span><span class="params">(consignment *pb.Consignment)</span> <span class="params">(*pb.Consignment, error)</span></span> &#123;</span><br><span class="line">	repo.mu.Lock()</span><br><span class="line">	updated := <span class="built_in">append</span>(repo.consignments, consignment)</span><br><span class="line">	repo.consignments = updated</span><br><span class="line">	repo.mu.Unlock()</span><br><span class="line">	<span class="keyword">return</span> consignment, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetAll consignments</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(repo *Repository)</span> <span class="title">GetAll</span><span class="params">()</span> []*<span class="title">pb</span>.<span class="title">Consignment</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> repo.consignments</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Service 需要实现protobuf.service中的所有定义，可以直接在pb.go中查找需要实现</span></span><br><span class="line"><span class="comment">// 的方法以及函数签名。</span></span><br><span class="line"><span class="keyword">type</span> service <span class="keyword">struct</span> &#123;</span><br><span class="line">	repo repository</span><br><span class="line">	vesselClient vesselProto.VesselServiceClient</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateConsignment - 创建货运订单(安排)</span></span><br><span class="line"><span class="comment">// 在proto中，我们给这个微服务定了两个方法，其中之一就是这个CreateConsignment方法</span></span><br><span class="line"><span class="comment">// 它接受一个context以及proto中定义的Consignment消息，这个Consignment是由</span></span><br><span class="line"><span class="comment">// gRPC的服务器处理后提供给你的.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *service)</span> <span class="title">CreateConsignment</span><span class="params">(ctx context.Context, req *pb.Consignment, res *pb.Response)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里调用vessel-service中的方法，直接传入vessel列表</span></span><br><span class="line">  <span class="comment">// 如果条件达成，就可以找到合适的vessel</span></span><br><span class="line">	vesselResponse, err := s.vesselClient.FindAvailable(context.Background(), &amp;vesselProto.Specification&#123;</span><br><span class="line">		MaxWeight: req.Weight,</span><br><span class="line">		Capacity: <span class="keyword">int32</span>(<span class="built_in">len</span>(req.Containers)),</span><br><span class="line">	&#125;)</span><br><span class="line">	log.Printf(<span class="string">"Found vessel: %s \n"</span>, vesselResponse.Vessel.Name)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We set the VesselId as the vessel we got back from our</span></span><br><span class="line">	<span class="comment">// vessel service</span></span><br><span class="line">	req.VesselId = vesselResponse.Vessel.Id</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Save our consignment</span></span><br><span class="line">	consignment, err := s.repo.Create(req)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res.Created = <span class="literal">true</span></span><br><span class="line">	res.Consignment = consignment</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetConsignments -</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *service)</span> <span class="title">GetConsignments</span><span class="params">(ctx context.Context, req *pb.GetRequest, res *pb.Response)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	consignments := s.repo.GetAll()</span><br><span class="line">	res.Consignments = consignments</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	repo := &amp;Repository&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set-up micro instance</span></span><br><span class="line">	srv := micro.NewService(</span><br><span class="line">		micro.Name(<span class="string">"shippy.service.consignment"</span>),</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	srv.Init()</span><br><span class="line"></span><br><span class="line">	vesselClient := vesselProto.NewVesselServiceClient(<span class="string">"vessel"</span>, srv.Client())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register handlers</span></span><br><span class="line">	pb.RegisterShippingServiceHandler(srv.Server(), &amp;service&#123;repo, vesselClient&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Run the server</span></span><br><span class="line">	<span class="keyword">if</span> err := srv.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码我们创建了一个货船服务的客户端实例，通过这个实例我们可以使用服务名 <code>vessel</code> 来调用货船服务中的方法。在这种情况下，只要调用一个方法  <code>FindAvailable</code>，我们就将货物的重量以及需要运输的集装箱数量作为详细说明发送给货船服务 <code>vessel-service</code> ，后者会返回一个合适的船只。</p>
<br/>

<p>也要修改 <code>consignment-cli/consignment.json</code> 文件，修改之前写死的 <code>vessel_id</code>，我们想要确认 <code>vessel-service</code>是否能正常的生成 <code>vessel_id</code>，所以在文件中加入一些集装箱和它们的重量信息:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"This is a test consignment"</span>,</span><br><span class="line">  <span class="attr">"weight"</span>: <span class="number">55000</span>,</span><br><span class="line">  <span class="attr">"containers"</span>: [</span><br><span class="line">    &#123; <span class="attr">"customer_id"</span>: <span class="string">"cust001"</span>, <span class="attr">"user_id"</span>: <span class="string">"user001"</span>, <span class="attr">"origin"</span>: <span class="string">"Manchester, United Kingdom"</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">"customer_id"</span>: <span class="string">"cust002"</span>, <span class="attr">"user_id"</span>: <span class="string">"user001"</span>, <span class="attr">"origin"</span>: <span class="string">"Derby, United Kingdom"</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">"customer_id"</span>: <span class="string">"cust005"</span>, <span class="attr">"user_id"</span>: <span class="string">"user001"</span>, <span class="attr">"origin"</span>: <span class="string">"Sheffield, United Kingdom"</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，在 <code>consignment-cli</code>中运行 <code>$ make build &amp;&amp; make run</code>，你应该可以看到返回信息，其中包含已经创建的货运清单，里面也已经设置好了 <code>vessel_id</code>。</p>
<br/>

<p>那么到此为止，我们已经拥有两个相互连接的微服务和一个命令行界面了。</p>
<p>本系列的下一篇文章将会介绍如何使用MongoDB进行数据持久化，而且我们还会添加第三项服务，并使用docker-compose在本地管理我们不断增加的容器。</p>
<br/>

<p>代码仓库：</p>
<ol>
<li><a href="https://github.com/EwanValentine/shippy-service-consignment">shippy-service-consignment</a></li>
<li><a href="https://github.com/EwanValentine/shippy-service-vessel">shippy-service-vessel</a></li>
<li><a href="https://github.com/EwanValentine/shippy-cli-consignment">shippy-cli-consignment</a></li>
</ol>
<p>觉得这系列文章对您有帮助，可以请原作者喝杯咖啡，Cheers! <a href="https://monzo.me/ewanvalentine">https://monzo.me/ewanvalentine</a>.</p>
<p>或者通过 <a href="https://www.patreon.com/ewanvalentine">Patreon</a> 来支持原作者。</p>
<br/>

</div><div class="article-tags size-small is-uppercase mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Golang/">Golang</a><a class="link-muted mr-2" rel="tag" href="/tags/Microservices/">Microservices</a><a class="link-muted mr-2" rel="tag" href="/tags/Translation/">Translation</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/04/11/MicroservicesinGolangPart3/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Microservices in Golang - Part3</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/04/07/MicroservicesinGolangPart1/"><span class="level-item">Microservices in Golang - Part1</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3 is-sticky"><div class="card widget" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex" href="#引言"><span class="mr-2">1</span><span>引言</span></a></li><li><a class="is-flex" href="#Docker简介"><span class="mr-2">2</span><span>Docker简介</span></a></li><li><a class="is-flex" href="#直到容器出现"><span class="mr-2">3</span><span>直到容器出现</span></a></li><li><a class="is-flex" href="#回到代码"><span class="mr-2">4</span><span>回到代码</span></a></li><li><a class="is-flex" href="#Go-micro"><span class="mr-2">5</span><span>Go-micro</span></a></li><li><a class="is-flex" href="#Vessel-service-船只管理服务"><span class="mr-2">6</span><span>Vessel service (船只管理服务)</span></a><ul class="menu-list"><li><a class="is-flex" href="#protobuf"><span class="mr-2">6.1</span><span>protobuf</span></a></li><li><a class="is-flex" href="#main-go"><span class="mr-2">6.2</span><span>main.go</span></a></li><li><a class="is-flex" href="#consigment-service"><span class="mr-2">6.3</span><span>consigment-service</span></a></li></ul></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-09-18T08:51:10.000Z">2020-09-18</time></p><p class="title is-6"><a class="link-muted" href="/2020/09/18/CustomScheduler3/">Schedule Framework 扩展调度器</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-29T13:30:34.206Z">2020-07-29</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/29/Kubernetes-rtfsc1/">[RTFSC]Kubernetes 资源对象与控制器</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/DeepIn/">DeepIn</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-10T13:30:36.000Z">2020-07-10</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/10/k8s-RABC/">Kubernetes RABC 权限控制</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Operations/">Operations</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-12T09:07:50.000Z">2020-06-12</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/12/LinuxPerformanceTool/">Linux性能调优</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Operations/">Operations</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-03T13:44:16.000Z">2020-06-03</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/03/LinuxNetworkAnalyze/">Linux 网络分析</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Operations/">Operations</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Fusidic&#039;s blog" height="28"></a><p class="size-small"><span>&copy; 2020 arithbar</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://fusidic.github.io',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>